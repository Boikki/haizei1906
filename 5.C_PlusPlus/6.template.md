
## Template 模版

#### 程序 = 算法 + 数据结构

数据结构和算法都有类型抽象的概念

数据结构能存储任意类型，算法能操作存储任意类型的数据结构

之前我们写的队列本来可以存储任意类型，比如`int`型队列，`double`型队列，`Node *`型队列。

他们的所有操作全都一样，但是我们却要声明很多次，做了很多无用的劳动。


##### 程序设计 = 数据结构 + 算法 + 编程范式

编程范式有:
    1. 面向过程编程
    2. 面向对象编程
    3. 函数式编程
    4. 泛型编程
    5. 可微分编程


泛型编程可以解决这个问题，减少很多代码的重复操作，提高开发效率。

其实我们学习面向对象，甚至之前C语言学习的函数和宏定义不都是为了减少

重复劳动吗，泛型编程正是我们接触到的第三种提高效率的编程范式。

**解决的问题：将数据类型抽象出来**

所以可以实现一个操作任意类型的过程

但是注意边界条件

#### 模版


##### 模版
**模版既不是定义又不是声明**
叫模版定义

真正的定义应该是存在于链接阶段的，但是实际上在编译阶段前，typename就已经被扩展成了相关的类

>代码 -预处理-> 处理过的代码(.i) -编译-> 对象文件(.o) -链接-> 可执行程序

对象文件中存放的是各个函数的定义，此时已经没有模版了。说明模版是在编译之前就被扩展成了相关的代码实例，也就是模版的作用相当于帮我们改写和制造代码。

这和宏定义作用的阶段一样，都是编译前(宏定义是预处理)。这样就完成了让编译器给我写代码。

但是模版比宏高级的地方是模版是有逻辑的，不是像宏一样简单的替换。

```c++
template<typename T>
T add(T a, T b) {
    return a + b;
}

template<typename T>
struct PrintAny {
    PrintAny(std::ostream &out) : out(out) {}
    void << operator()(const T &a) {
        out << a;
    }
    std::ostream &out;
};
```

重载了()的对象会表现的像函数，叫**函数对象**

使用`int a; PrintAny(a);`

##### 模版类 + 模版函数

```c++
template<typename T>
struct Print {
    template<typename U>
    void << operator()(const U &a) {
        cout << a << endl;
        cout << this->__temp << endl;
    }
    void set(const T &temp) { this->__temp = temp; }
    T __temp;
};

Print<int> (a);
Print<long long> (b);
```

这就是个更高级的PrintAny，可以传入任意类型不用事先声明
只要是给Print传任意类型参数，他就会扩展出任意多的类来。
在此期间`()`重载的次数是不确定的，要根据编译器的最终扩展的状态确定。

发没发现使用方法很像stl模版


#### 特化与偏特化


```c++
template<typename T>
T add(T a, T b) {
    return a + b;
}

template<>
int add(int a, int b) {
    return a = b + 2;
}
```

特化就是对特定的情况直接规定类型，有点像递归函数的边界条件


```c++
template<>
struct PrintAny<int> {
    PrintAny(std::ostream &out) : out(out) {}
    void << operator()(const T &a) {
        out << a;
    }
    std::ostream &out;
};
```
这样有int型变量就会优先匹配这个模版

##### 匹配的先后顺序: 特化模版->偏特化模版->模版

##### 偏特化

```c++
template<typename T>
void P(T *a) {
    cout << *a << endl;
}
```
只告诉我们当a为T *的时候输出指针

不该的话输出不了T *

模版是图灵完备的，也就是说模版可以用来实现目前的大多数程序和算法

并且模版是在编译的时候就已经扩展完了，运行期只是输出一个结果，也就是运行的时间复杂度为$O(1)$

编译期实际上就相当于运行期了
#### 可变参模版

之前的模版都类比函数，这里也一样

```c++
template<typename T, typename ...ARGS>

void Print(const T &a, ARGS... args) {
    cout << a << endl;
    Print(args...);
}
```

此代码会递归展开args

那你可能要注意了，为什么要用`const T&`

不用的话报错:

>6.template_args.cpp:51:6: note: candidate function [with T = int, ARGS = <double, const char *>] not viable: expects an lvalue for 1st argument
>void print(T &a, ARGS... args) {

也就是模版函数需要一个左值，但是`int`类型却是一个右值。

**类拷贝构造函数的参数使用常量左值引用类型（const T&）是由于“常量引用”是一种全能类型，它即可以接纳左值，也可以接纳右值。**

或者写一个转换模版函数，进行左右值的转换

就像递归函数一样，它也需要终止条件，这里终止条件是一个参数的Print模版函数

```c++

template<typename T>
Print(const T &a) {
    cout << a << endl;
}
```
递归展开的过程中每次可以获取一个参数

```c++
template<typename T>
void print(const T &a) {
    cout << a << endl;
    cout << "-------end--------" << endl;
    return ;
}
template<typename T, typename ...ARGS>
void print(const T &a, ARGS... args) {
    cout << a << endl;
    print(args...);
    return ;
}


template<typename T, typename ...U>
struct ARG {
    typedef T type;
    typedef ARG<U...> rest;
};
template<typename T>
struct ARG<T> {
    typedef T type;
};
```

注意看1-12行和15-23行代码段的不同

都是递归展开的模版，为什么print终止条件要在正式函数前而ARG的要在正式函数之后呢

本质上这两个print函数没关系，但是因为涉及到递归条件所以要放前边。

而`ARG<T>`是ARG的特化模版，如果放ARG前就找不到此特化模版了



往下走，看报错

```c++
6.template_args.cpp:69:18: error: missing 'typename' prior to dependent type name 'ARG<U...>::type'
    T operator()(ARG<U...>::type a) {
                 ^~~~~~~~~~~~~~~
                 typename
```

虽然ARG<U...>::type是类型，但是它是经过模版推导才得到的类型。要我们显式用typename来标注





看一段较为复杂的代码:

```c++
template<typename T, typename ...REST>
struct ARG {
    typedef T __type;
    typedef ARG<REST...> __rest;
};

template<typename T>
struct ARG<T> {
    typedef T __type;
};

template<typename T, typename ...ARGS> struct Test;
template<typename T, typename ...ARGS>
struct Test<T(ARGS...)> {
    T operator()(typename ARG<ARGS...>::__type a, typename ARG<ARGS...>::__rest::__type b) {
        return a + b;
    }
}

```
这段代码做了什么？

首先这是一个模版类，第一个模版类做的就是将第一个参数提出来，假设第一次有n个参数，那么 `__rest` 里就是n - 1

这样依然是递归展开的

并且我们用`__type`强制替代第一个参数的类型，不管你是int还是long long ，到这里都是`__type`

`__rest`里存的是剩下的n - 1个参数，其中又能展开成`__rest::__type, __rest::__rest`
这样依次下去就能取到第二个甚至第三个的类型


#### 思考题：如何让Test::__rest部分只包含两个参数呢？

思路：让编译器在不是2个参数的时候报错

```c++
template<typename T, typename ...REST>
struct ARG {
    typedef T __type;
    typedef ARG<REST...> __rest;
};

template<typename T>
struct ARG<T> {
    typedef T __type;
    typedef T __final;
};

template<typename T, typename ...ARGS> struct Test;
template<typename T, typename ...ARGS>
struct Test<T(ARGS...)> {
    T operator()(typename ARG<ARGS...>::__type a, typename ARG<ARGS...>::__rest::__final b) {
        return a + b;
    }
};

int main() {
    Test<int(double, int)> func_a;
    Test<int(int, int, int)> func_b;
    cout << func_a(1.9, 79) << endl;
    return 0;
}
```

只是在10行加一行代码，就完成了。为啥呢？

你看，如果是两个参数的传进来，那么取第二个参数的时候，用到的是终止条件模版类

也就是给T取一个别名叫`__final`，能取到`__final`的就一定是有两个参数的。

另外重载运算符的时候也要取`__final`，就能取到终止的那个参数，也就是第二个参数。



##### 但是这样未免太麻烦啦！要是取ARGS里的第5个参数得用四次::rest

#### 模版的图灵完备性



我们想实现一个`ARGS<5, ARGS...>`这样直接取到第5个参数的功能

做个小实验：

```c++
template<int n, int m>
void func() {
    cout << n + m << endl;
    return ;
}

func<3, 4>();
```

这说明模版不仅可以传类型进去，还可以传值进去

要再传入一个整形进去直接获取第n个参数



```c++
template<int n, typename T, typename ...U>
struct ARG {
    typedef typename ARG<n - 1, U...>::getT getT;
};
template<typename T, typename ...U>
struct ARG<1, T, U...> {
    typedef T getT;
};
template<typename T, typename ...U> struct Convertor;
template<typename T, typename ...U>
struct Convertor<T(U...)> {
    T operator()(const typename ARG<1, U...>::getT &a, const typename ARG<2, U...>::getT &b) {
        return a;
    }
};
```

首先完成基本函数的编写，递归一次n - 1，将第一个参数类型强制命名成getT

终止条件为ARG的偏特化版本，此时n不是变量了，传入1，T，U...依然是变量

如果不偏特化n = 1，那么他还会继续获取第n - 1个的参数

这样就取到了第n个参数

```c++
template<int n, typename T, typename ...ARGS>
struct ARG {
    typedef typename ARG<n - 1, ARGS...>::getT getT;
    typedef ARG<n - 1, ARGS...> N;
};

template<typename T, typename ...ARGS>
struct ARG<0, T, ARGS...> {
    typedef T getT;
};

template<typename T>
struct ARG<0, T> {
    typedef T getT;
    typedef T __final;
};

template<typename T, typename ...ARGS> class Test;
template<typename T, typename ...ARGS>
class Test<T(ARGS...)> {
public :
    T operator()(typename ARG<0, ARGS...>::getT a, typename ARG<1, ARGS...>::N::__final b) {
        return a + b;
    }
};
```



*整个模版的设计过程简直和我们递归函数设计的过程一模一样，先设计递归，在设计边界条件*



#### 完美的ADD模版

要想设计出一个简单的add模版不难，直接

```c++
template<typename T>
T add(T &a, T &b) {
    return a + b;
}
```
但是这种只能完成单一类型的类型加减

要想完成任意类型的加减就要设三个类型，但是这么写未免太麻烦了

```c++

template<typename R, typename T, typename U>
R add(T &a, u &b) {
    return a + b;
}
add<decltype(a + b)>add(a + b);
```
还得获取a + b结果的类型，用decltype关键字。
这个关键字只返回相应的类型，并不参加计算，和sizeof, typeof差不多

都是作用在预处理阶段的命令

但是decltype是和template一样是在预处理之后才作用的，更推荐此方式

>1. 预处理阶段展开宏(typeof)
>2. 模版的实例化
>3. decltype

这也就是为什么c++中更推荐decltype的使用，因为typeof作用的时候模版还没展开，无法获取返回值

用来确定表达式的值，比如有一个exp的值我们不好确定，可以用`decltype(exp()) x;` 的形式声明一个同类型的x

知道了decltype，此时add模版就可以写成
`decltype(T() + U())`
这样获取T类型和U类型和的类型

但是这种方法依然会对自建类型A报错:
>
6.prefect_add_template.cpp:35:13: error: no matching function for call to 'add'
    cout << add(a, d) << endl;
            ^~~
6.prefect_add_template.cpp:24:21: note: candidate template ignored: substitution failure [with T = int, U = A]: no matching constructor for initialization of 'A'
decltype(T() + U()) add(T &a, U &b) {  

也就是匹配不到U类型也就是A类的构造函数

`decltype(T() + U())` 是需要T和U的构造函数的

所以我们可以这么写:
    可以将一个特殊的地址转换成一个对象，然后再取反不就是此类型的对象了吗！
    `*(T *)(0)`这样就完成了一个取x为0的T类型对象

但是c++11为我们提供了更完美的实现方法，就是

##### 函数返回值后置

可以用`auto`关键字前置，然后`->`指向后边的函数类型

`auto add(T &a, U &b) -> decltype(a + b)`

正好也避免了之前`decltype(a + b) add(T &a, U &b)`
报错a,b 为定义的问题

#### 模版求素数

先来个简单的引入，模版求奇数

用模版传入n

```c++
template<int n>
struct IsOdd {
public :
    const static bool r = n % 2;
};

IsOdd<3>;
```

但是求素数就复杂一些了

普通的求素数代码长这样

```c++
for (int i = 2; i * i <= n; i++) {
    if (n % i) return false;
}
return true;
```

我们要做的就是改写成模版类

明显普通的代码有两个变量，这里模版也需要传入n，i两个变量

```c++
template<int n>
struct IsPrime {
    IsPrime();
    const static bool r = TestPrime<n, 2>::r;
};
```

我们将i = 2直接作为值传入封装好的TestPrime模版

在TestPrime中要完成两种终止情况的处理，一种是n = 0，一种是i越界

n = 0代表能整除，不是素数。i越界我们用i = 0来表示，还方便，代表是素数



```c++
template <int i>
struct TestPrime<0, i> {
    const static int r = 0;
};
template <int n>
struct TestPrime<n, 0> {
    const static int r = 1;
};
```

由此衍生出的两个特化模版

接下来我们要实现循环里那样每次更新i和n的值，i每次就 += 1， 因为上文设定了除尽的时候n = 0，所以这里要实现这个功能

i不越界每次就 += 1，越界就 = 0即可

还是把它俩封装到不同的模版中，用模版中的r值来实现对n和i的访问

```c++
template<int n, int i>
struct GetNextN {
    const static int r = (n > 0 && n % i != 0) * n;
};

template<int n, int i>
struct GetNextI {
    const static int r = (i * i <= n ? i + 1 : 0);
};

template <int n, int i>
struct TestPrime {
    const static int r = TestPrime<GetNextN<n, i>::r, GetNextI<n, i>::r>::r;
};
```







#### 模版的引用折叠 reference collapsing

先来看一份简单的swap模版代码

```c++
template<typename T>
void my_swap(T &&a, T &&b) {
    T c;
    c = a;
    a = b;
    b = c;
    return ;
}
int main() {
    int a = 123, b = 456;
    my_swap(a, b);
    cout << a << " " << b << endl;
    my_swap(move(a), move(b));
    cout << a << " " << b << endl;
    return 0;
}
```

c++中有左值右值之分，my_swap要求传入的两个都是左值

使用move将左值变成右值之后就报错了

但是如果将`void my_swap(T &a, T &b)`这个左值引用加上一个引用就变成右值引用了

`void my_swap(T &&a, T &&b)`

这样以来报错的就会是3行

为啥`T c;`会报错呢？

##### template的类型自动推导

首先11行`a, b`为左值，所以`T &&a, T &&b`中的T &&也应为左值引用

所以T应该是左值引用类型，根据我们之前的引用折叠知识`T &&& == T &`

所以`T c;`c就变成引用了，自然不合法了。

报错信息：

 >6.type_template.cpp:21:5: note: in instantiation of function template specialization 'my_swap<int &>' requested here
 >    my_swap(a, b);
 >    ^
 >1 error generated.

也是说明了T是左值引用类型，为`T = int &`

即`T && = int &&& = int &`

如果再加一个引用呢？就又变回左值引用了

c++11在>=三个引用的时候会自动删掉两个引用

这就是天生为模版准备的！

##### 一套帮助我们更正类型的工具 remove_reference

顾名思义 可以去除类型的引用

`    typename remove_reference<T>::type c;`



##### template里也有函数指针

`void func(function<void(int &, int &)> f, int &a, int &b);`

但是这样找不到function函数，还是得用经典的函数指针

```c++
void func(void (*p)(int &, int &), int &a, int &b) {
    p(a, b);
    return ;
}
func(add, a, b);
```

重点关注template是如何进行类型推导的



`add`template是通过func里提供的函数指针传入参数来反向推导add函数里的类型，应该是左值引用`int &`



#### Bind方法 -- 绑定函数

```c++
void func(int x, int y, int z) {
    cout << x + y << " is a number. " << endl;
    cout << "z " << z << endl;
    return ;
}    
	function<void(int, int)> f = bind(func, 123, placeholders::_2, placeholders::_1);
    f(100, 101);
    f(200, 201);
```

将func绑定到f上，其中x绑定为123，剩下的值不想绑定可用`std::placeholders::_1 ~ std::placeholders::_10`来做占位符

但是这个占位符的顺序和变量值绑定的顺序一样么

做个实验，发现z输出的值为100 200

这说明`placeholders::_2`bind在`function<void(int, int)>`的第二个int上，bind在y上，所以传入的是 101 201



`placeholders::_1`bind在`function<void(int, int)>`的第一个int上，bind在y上



Bind还可以绑定在类上

```c++
struct A {
    const void say() {
        cout << this << " : saying" << endl;
        return ;
    }
};

int main() {
    A a;
    cout << &a << endl;
    function<void()> f2 = bind(&A::say, a);
    f2();
    return 0;
}
```

我们在多态里学到过成员方法的传入参数一定有个隐藏的参数`this`指针

所以bind要绑定上A的成员方法和a对象

但是10和12行输出的地址却不一样，这是因为在bind时发生了拷贝构造

要是想绑定a这个对象就传入`function<void()> f2 = bind(&A::say, ref(a));`即可



bind可以绑一切，尤其是在用一些高级库或者多线程开发的时候

下面实现一个给bind传入bind好的方法并统计该方法调用次数的功能



```c++
void count_function_times(function<void()> &p, int &cnt) {
    p();
    cnt++;
    return ;
}
    function<void()> f3 = bind(&A::run, ref(a));
    int cnt = 0;
    function<void()> f4 = bind(count_function_times, ref(f3), ref(cnt));
    for (int i = 0; i < rand() % 10; i++) {
        f4();
    }
    cout << cnt << endl;
```

注意传入的都是引用，因为我们要切实获取bind之后的f3方法，而不是她的拷贝和真切修改cnt值

输出

>run
>run
>run
>run
>4

