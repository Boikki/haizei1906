
## Template 模版

#### 程序 = 算法 + 数据结构

数据结构和算法都有类型抽象的概念

数据结构能存储任意类型，算法能操作存储任意类型的数据结构

之前我们写的队列本来可以存储任意类型，比如`int`型队列，`double`型队列，`Node *`型队列。

他们的所有操作全都一样，但是我们却要声明很多次，做了很多无用的劳动。


##### 程序设计 = 数据结构 + 算法 + 编程范式

编程范式有:
    1. 面向过程编程
    2. 面向对象编程
    3. 函数式编程
    4. 泛型编程
    5. 可微分编程


泛型编程可以解决这个问题，减少很多代码的重复操作，提高开发效率。

其实我们学习面向对象，甚至之前C语言学习的函数和宏定义不都是为了减少

重复劳动吗，泛型编程正是我们接触到的第三种提高效率的编程范式。

**解决的问题：将数据类型抽象出来**

所以可以实现一个操作任意类型的过程

但是注意边界条件

#### 模版


##### 模版
**模版既不是定义又不是声明**
叫模版定义

真正的定义应该是存在于链接阶段的，但是实际上在编译阶段前，typename就已经被扩展成了相关的类

>代码 -预处理-> 处理过的代码(.i) -编译-> 对象文件(.o) -链接-> 可执行程序

对象文件中存放的是各个函数的定义，此时已经没有模版了。说明模版是在编译之前就被扩展成了相关的代码实例，也就是模版的作用相当于帮我们改写和制造代码。

这和宏定义作用的阶段一样，都是编译前(宏定义是预处理)。这样就完成了让编译器给我写代码。

但是模版比宏高级的地方是模版是有逻辑的，不是像宏一样简单的替换。

```c++
template<typename T>
T add(T a, T b) {
    return a + b;
}

template<typename T>
struct PrintAny {
    PrintAny(std::ostream &out) : out(out) {}
    void << operator()(const T &a) {
        out << a;
    }
    std::ostream &out;
};
```

重载了()的对象会表现的像函数，叫**函数对象**

使用`int a; PrintAny(a);`

##### 模版类 + 模版函数

```c++
template<typename T>
struct Print {
    template<typename U>
    void << operator()(const U &a) {
        cout << a << endl;
        cout << this->__temp << endl;
    }
    void set(const T &temp) { this->__temp = temp; }
    T __temp;
};

Print<int> (a);
Print<long long> (b);
```

这就是个更高级的PrintAny，可以传入任意类型不用事先声明
只要是给Print传任意类型参数，他就会扩展出任意多的类来。
在此期间`()`重载的次数是不确定的，要根据编译器的最终扩展的状态确定。

发没发现使用方法很像stl模版


#### 特化与偏特化


```c++
template<typename T>
T add(T a, T b) {
    return a + b;
}

template<>
int add(int a, int b) {
    return a = b + 2;
}
```

特化就是对特定的情况直接规定类型，有点像递归函数的边界条件


```c++
template<>
struct PrintAny<int> {
    PrintAny(std::ostream &out) : out(out) {}
    void << operator()(const T &a) {
        out << a;
    }
    std::ostream &out;
};
```
这样有int型变量就会优先匹配这个模版

##### 匹配的先后顺序: 特化模版->偏特化模版->模版

##### 偏特化

```c++
template<typename T>
void P(T *a) {
    cout << *a << endl;
}
```
只告诉我们当a为T *的时候输出指针

不该的话输出不了T *

模版是图灵完备的，也就是说模版可以用来实现目前的大多数程序和算法

并且模版是在编译的时候就已经扩展完了，运行期只是输出一个结果，也就是运行的时间复杂度为$O(1)$

编译期实际上就相当于运行期了
#### 可变参模版

之前的模版都类比函数，这里也一样

```c++
template<typename T, typename ...ARGS>

void Print(const T &a, ARGS... args) {
    cout << a << endl;
    Print(args...);
}
```

此代码会递归展开args

就像递归函数一样，它也需要终止条件，这里终止条件是一个参数的Print模版函数

```c++

template<typename T>
Print(const T &a) {
    cout << a << endl;
}
```
递归展开的过程中每次可以获取一个参数

看一段较为复杂的代码:

```c++
template<typename T, typename ...REST>
struct ARG {
    typedef T __type;
    typedef ARG<REST...> __rest;
};

template<typename T>
struct ARG<T> {
    typedef T __type;
};

template<typename T, typename ...ARGS> struct Test;
template<typename T, typename ...ARGS>
struct Test<T(ARGS...)> {
    T operator()(typename ARG<ARGS...>::__type a, typename ARG<ARGS...>::__rest::__type b) {
        return a + b;
    }
}

```
这段代码做了什么？

首先这是一个模版类，第一个模版类做的就是将第一个参数提出来，假设第一次有n个参数，那么 `__rest` 里就是n - 1

这样依然是递归展开的

并且我们用`__type`强制替代第一个参数的类型，不管你是int还是long long ，到这里都是`__type`

`__rest`里存的是剩下的n - 1个参数，其中又能展开成`__rest::__type, __rest::__rest`
这样依次下去就能取到第二个甚至第三个的类型


#### 思考题：如何让Test::__rest部分只包含两个参数呢？

思路：让编译器在不是2个参数的时候报错

```c++
template<typename T, typename ...REST>
struct ARG {
    typedef T __type;
    typedef ARG<REST...> __rest;
};

template<typename T>
struct ARG<T> {
    typedef T __type;
    typedef T __final;
};

template<typename T, typename ...ARGS> struct Test;
template<typename T, typename ...ARGS>
struct Test<T(ARGS...)> {
    T operator()(typename ARG<ARGS...>::__type a, typename ARG<ARGS...>::__rest::__final b) {
        return a + b;
    }
};

int main() {
    Test<int(double, int)> func_a;
    Test<int(int, int, int)> func_b;
    cout << func_a(1.9, 79) << endl;
    return 0;
}
```

只是在10行加一行代码，就完成了。为啥呢？

你看，如果是两个参数的传进来，那么取第二个参数的时候，用到的是终止条件模版类

也就是给T取一个别名叫`__final`，能取到`__final`的就一定是有两个参数的。

另外重载运算符的时候也要取`__final`，就能取到终止的那个参数，也就是第二个参数。



##### 但是这样未免太麻烦啦！要是取ARGS里的第5个参数得用四次::rest

我们想实现一个`ARGS<5, ARGS...>`这样直接取到第5个参数的功能

要再传入一个整形

```c++
template<int n, typename T, typename ...ARGS>
struct ARG {
    typedef typename ARG<n - 1, ARGS...>::getT getT;
    typedef ARG<n - 1, ARGS...> N;
};

template<typename T, typename ...ARGS>
struct ARG<0, T, ARGS...> {
    typedef T getT;
};

template<typename T>
struct ARG<0, T> {
    typedef T getT;
    typedef T __final;
};

template<typename T, typename ...ARGS> class Test;
template<typename T, typename ...ARGS>
class Test<T(ARGS...)> {
public :
    T operator()(typename ARG<0, ARGS...>::getT a, typename ARG<1, ARGS...>::N::__final b) {
        return a + b;
    }
};
```





#### 完美的ADD模版

要想设计出一个简单的add模版不难，直接

```c++
template<typename T>
T add(T &a, T &b) {
    return a + b;
}
```
但是这种只能完成单一类型的类型加减

要想完成任意类型的加减就要设三个类型，但是这么写未免太麻烦了

```c++

template<typename R, typename T, typename U>
R add(T &a, u &b) {
    return a + b;
}
add<decltype(a + b)>add(a + b);
```
还得获取a + b结果的类型，用decltype关键字。
这个关键字只返回相应的类型，并不参加计算，和sizeof差不多
decltype 用来确定表达式的值，比如有一个exp的值我们不好确定，可以用`decltype(exp()) x;` 的形式声明一个同类型的x


知道了decltype，此时add模版就可以写成
`decltype(T() + U())`
这样获取T类型和U类型和的类型

但是这种方法依然会对自建类型A报错:
>
6.prefect_add_template.cpp:35:13: error: no matching function for call to 'add'
    cout << add(a, d) << endl;
            ^~~
6.prefect_add_template.cpp:24:21: note: candidate template ignored: substitution failure [with T = int, U = A]: no matching constructor for initialization of 'A'
decltype(T() + U()) add(T &a, U &b) {  

也就是匹配不到U类型也就是A类的构造函数

`decltype(T() + U())` 是需要T和U的构造函数的

所以我们可以这么写:
    可以将一个特殊的地址转换成一个对象，然后再取反不就是此类型的对象了吗！
    `*(T *)(0)`这样就完成了一个取x为0的T类型对象


但是c++11为我们提供了更完美的实现方法，就是函数类型后置

可以用`auto`关键字前置，然后`->`指向后边的函数类型

    `auto add(T &a, U &b) -> decltype(a + b)`
    
    正好也避免了之前`decltype(a + b) add(T &a, U &b)`
    报错a,b 为定义的问题









