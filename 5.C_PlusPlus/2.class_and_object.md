
## 类与对象

#### 引入：类型

类型(float, int, long long)本质上也是微型数据结构

类型 = 类型定义 + 类型操作

类(class) 确定了对象的特征以及占用的空间

为什么叫对象(object)而非一个变量(var)呢

比如`int a = 3; a = 5;` 我们会发现我们想要的是a的值，而非a本身。值的重要性大于a本身。也就是值的自我属性非常差。

但是对象不一样了，数据的自我属性会非常强。**对象的方法和对象本身是强绑定的**

关键字: `struct & class`

```c
class People {
    string name;
    Day birthday;
    double height;
    double weight
    //成员属性，每个成员都有的

    void say(string word);
    void run(Location &loc);
    void eat(Food food) {}
    //成员方法，机制一样，但是表现不一样。比如我们说话，说话都是张嘴，但是每个人说话又不一样：
    //这就是不同的成员，成员属性不同，同样的成员方法，外在表现就不一样。
    //要先设计成员属性再设计成员方法
    //最后一个eat方法是声明 + 定义，其余的都是声明
};
```

#### 访问权限

不是说的两个对象的访问权限，说的是类和类之间的访问权限

比如有一个`People renboyu;`里边有一个方法需要访问其他的`People`对象，那么其他的`People`对象里的属性是可以访问到的！

所以说`private`只是限制了类之间的访问，而非对象间的访问。

`struct`关键字默认`pulic`. 如果是`class`关键字需要自行确定访问控制权限。


#### 构造函数 & 析构函数

构造函数: 
    初始化对象 **只要是对象能用了，就一定调用了相关的构造函数**
    1. 默认构造函数(无参构造函数) `People a;` 
    2. 有参构造函数 `People a("renboyu")` -- 一旦存在有参构造函数，默认构造函数就会被删除。
    设想一种情景，我们在改进代码的时候将之前默认构造函数换成了有参构造函数，
    那么之前代码里的全部涉及到构造的方法全都不好使了(报错匹配不到相应的构造函数)。这种就得显式性定义默认构造函数
    3. 拷贝构造函数 `People(const People &a)` 拷贝过程要自己实现，属于浅拷贝。**与=不等价!**
    `this->name = name; this->height = height;`就是这样依次赋值。


析构函数: 
    `~People();` 无参数，类销毁时自动执行，就把里边`malloc`的，还有指针都销毁了


#### 类属性和类方法

加上`static`关键字就变成了全局的，静态的属性或者方法

**`static`是用来声明类属性和方法的，定义的时候不能加它。如果有需求的话就要声明+`static`，定义不加分开写**





这种和类有关的，比如`People`类的总数，全人类总数就是类属性

设计原则:
    此方法是不是对象方法，放到全局方法合不合适
    如果都不符合，那么就设计成某个类的类方法

`const`关键字加在方法后，`const`方法；

`const People a`说明a的属性是不可修改的，如果a对象中有一个可以修改`name`属性的方法，那么逻辑上就产生了冲突。

这里加上了`const`的方法，可以被`const`类型的对象调用，解决了上文的逻辑不通问题。但是在`const`方法内部，
还是不能对属性进行修改，这就要借助`multable`关键字。所有被`multable`标记的属性可以被`const`方法修改

#### 对象与引用

引用就是对象的别名 * 是旧的底层实现细节，用指针就可以 *

引用是指针的简化版

`struct`默认访问权限为`public` ---- 为了兼容c
`class`默认访问权限为`private`

就是没有标识的时候，比如
```c
class A {
    int a, b, c;
};

```
`a, b, c`就是`private`



### 代码演示

**任何一个对象在生成前都经过了构造，不管什么构造函数**

```c++
class Point {
public :
    Point() : _x(0), _y(0) {}
    //参数列表形式的构造函数，推荐这一种
    //默认构造函数，当我们将5行替换它之后，原先的Point p1;就失效了
    //g++报错：no matching constructor for initialization of 'Point' 即找不到匹配的构造函数
    //并且参数列表里的构造顺序是和属性的定义顺序有关的
    //所以
    Ponit() : _y(0), _x(_y + 1);
    //这一行代码不会初始化_x的值为1，会给_x分一个随机值
    Point(int x, int y) : _x(x), _y(y) {}
    Point(const Point &p) {
        _x = p._x;
        _y = p._y;
    }
  
    int x() { return _x; }
    int y() { return _y; }


private :
    int _x, _y;
};

int main() {
    Point(p1), p2(2, 3), p3(p2);
    cout << p1.x() << p1.y() << endl;
    cout << p2.x() << p2.y() << endl;
    cout << p3.x() << p3.y() << endl;
    return 0;
}
```

​    展示一段不能通过编译的拷贝构造函数代码：

    ```c++
    Point(Point p) {
            _x = p._x;
            _y = p._y;
        }
    ```

​    g++报错：copy constructor must pass its first argument by reference
​    这里的p是一个独立的对象，不是引用。
​    比如`Point a(b)` 因为传入的b需要拷贝给p，那么就有了`Ponit a(p(b))`，但是p的拷贝构造函数里还有一个p。这就无限展开了，爆栈了

​	所以这就和C的实参形参一样，传入形参肯定不行的。所以传入引用，也就是实参。

​	为了严谨性，将p换成const型，不允许修改p的值。

**碎碎念：将错误尽可能暴露在编译阶段**



```c++
Point() : _x(0), _y(0) {
    _x++;
}
```

构造的时候，先初始化参数列表，再进行大括号里的行为。如上代码输出`10`

如果先进行大括号里的会输出`00`的



#### 析构函数

析构的顺序和构造的顺序相反 --- 像栈一样

什么原因呢？

比如构造的时候顺序是 `1->2->3`那么很可能3的析构是依赖前两个对象的，如果先析构最先构造的，则可能导致后构造的析构出问题。

这就是语言开发者，编译器编写者所考虑的。

------





##### 隆重引入this指针

this具有指针具有的所有性质，指向当前对象

`this->_x`简介引用访问`_x`



----------------

如果我们想有一个类属性来记录对象的总数

可以有一个`static int _cnt;`

在方法中方法`static cnt() int { return Point::_cnt; }`

但是这样报了链接时的错误：

```shell
Undefined symbols for architecture arm64:
  "Point::_cnt", referenced from:
      Point::cnt() in 2-56425d.o
ld: symbol(s) not found for architecture arm64
```

未定义的符号，这是什么意思呢。

`static cnt() int { return Point::_cnt; }`是将定义和声明放到了一起，但是`static`关键字只能用于声明哦。所以编译器会将cnt看作是未定义的符号

为了解决这种，我们就需要将声明与定义分开写。

这就又引出了命名空间`namespace`的问题

`using namespace std`就是用标准库函数的命名空间

那么对于一个类来说，`class Point {};`大括号里的就是它的命名空间

所以将类的定义写出去就要加上`Point::`命名空间

 



**`static`是用来声明类属性和方法的，定义的时候不能加它。如果有需求的话就要声明+`static`，定义不加分开写**



-----

##### 委托构造

不管哪一个构造函数运行，我都让他从指定的构造函数开始构造

将 `Point(int x, int y) : _x(x), _y(y) {}`改成`Point(int x, int y) : Point() { this->_x = x, this->_y = y}`

有委托构造就不能有构造列表了，所以把赋值操作移到方法内部



----

##### const

`private `里的值相当于`const`值，而const值只能被const方法调用

比如拷贝构造函数写成

```c++
Point::Point(const Point &p) : Point(){
    _x = p.x();
    _y = p.y();
    cout << "copy constructor" << endl;
    cout << this <<endl;
}
```

报错

'this' argument to member function 'x' has type 'const Point', but function is not marked const

这就是因为`_x`是const类型，但是`x()`不是const类型的方法。解决这个很简单，将`x(), y()`变成const类型即可



----

##### 新需求 - mutable

假设有一个用`_z`记录变量x被访问的次数的需求，就需要在`x()`中加上`this->_z += 1;`

但是报错：

cannot assign to non-static data member within const member function 'x'

也就是不能在const方法中对非static的属性赋值修改

这时还想修改就要将`int _z`改成`mutable int _z;`

