
## THREAD

#### 如果面试官问你，你这个项目为什么要用多进程，不用多线程？ 那么接下来

#### 再提程序、进程和线程
程序是:
    保存在存储介质上，指定方式编译成的(为了适应某种操作系统或者计算机体系架构)，可执行但是还未执行的文件
进程是:
    操作系统对运行程序的抽象，是程序在内存的镜像。是分配资源的最小单位
    包括：加载的二进制程序、虚拟内存、内核资源、关联的用户

线程是:
    进程内的执行单元，包括：虚拟处理器，堆栈，程序状态，是执行操作的最小单位

进程就是正在执行的二进制程序，线程是OS调度器可调度的最小单元

#### 虚拟内存 虚拟处理器

#### 多线程的好处:
    1. 抽象编程:
        比如多进程`fork()`完了，代码是从`fork`的地方继续往下执行的
        而且你还得在接下来用pid来判断是父进程还是子进程
        但是多线程你就不用判断
    2. 并发性:
        1个进程分成多个线程，就可以在多个处理器上跑了，这样就实现了并发
        当然进程也可实现，用之前的CPU亲和力就行
    3. 提高响应能力:
        没有阻塞，可以做个线程池或者消息队列暂存
    4. IO阻塞:
        如果在等IO，只有单个线程一定会阻塞，但是可以但开个线程让他阻塞去
        解决它用epoll和非阻塞IO都可以哦
    5. 上下文切换:
        线程的上下文切换成本远远小于进程的，线程用的是同一块虚拟内存
        (当然进程切换对Linux来说开销也不是很高)
    6. 内存保存:
        线程的虚拟内存

#### 多线程的坏处:
    1. 多个并发同时访问一块内存
    2. 线程同步容易出BUG
    3. 调试困难

#### 线程的由来
和进程一样，线程也不能凭空产生
##### 内核级的线程模型(常用)
1. `pthread_create()`之后，内核空间的线程可以直接转化为
2. 因为内核空间的线程和用户线程数量是1:1，所以也叫1:1线程模型
3. kernel中的线程库通过`clone()`创建一个线程，返回的进程直接作为用户的线程

**线程本质上就是个轻量级的进程**

##### 用户级的线程模型 
1. 一个内核线程保护N个用户空间的线程
2. 用户级的线程模型上下文切换成本为0，应用本身可决定换哪个

缺点:
    - 因为只有一个内核线程，一个内核线程只能用一个CPU，因此无法提供真正的并行。这个缺点对OS来说是致命的，
    因为本来Linux上下文切换，进程切换的成本就不高，以牺牲并发来换取微弱的上下文优势并不合理。而且现在CPU都是多核的
    其动机就是为了让你提高并发
#### 线程模式 - 每个连接对应一个线程
来一个连接我用一个线程去服务他，直到这个连接处理完成
其实之前聊天室最开始的版本不就是这样么，这就是线程池的思想
## Homework 实现一个线程池
#### 线程模式 - 事件驱动型
很像`select, epoll`这种等待内核返回的
阻塞在某个位置，在内核空间中，内核告诉IO多路复用函数让他返回 
是当前设计多线程服务器的最佳选择


#### 并发、并行和竞争

并行是硬件特征，并发计算就是有很多处理器
并发是编程模式，写的程序能提供并发这种服务，在一个处理器上也可

竞争：共享资源，数据竞争、临界区
共享资源：硬件，内核资源，内存上的变量
多个线程同时重叠的访问共享资源就会有竞争








