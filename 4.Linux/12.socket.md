
## SOCKET 编程

#### socket 
```c++

int socket(int domain, int type, int protocol);

domain : 
    AF_INET(IPV4), AF_INET6(IPV6), AF_LOCAL(本地网络，适用于本地进程间通信), AF_ROUTE
type : 
    SOCK_STREAM(字节流TCP), SOCK_GDRAM(数据报UDP), SOCK_PACKET, SOCK_SEQPACKET(后两个不用记)

protocol : 
    IPPROTO_TCP, IPPROTO_UDP, IPPROTO_STCP, IPPROTO_TIPC(后两者不常用)
RETURN VALUE :
    socket fd(file describer) 文件描述符
```

在确定了AF_INET, SOCK_STREAM之后，protocol项只剩一种选择即IPPROTO_TCP, 这时可以用0代替，编译器会自动补上

##### 什么是fd? 
标准输入、输出、标准错误输出的012就是fd


#### bind 
```c++
int bind(int sockfd, const struct sockaddr *addr, socketlen_t addrlen);

RETURN VALUE :
    -1为错误，并设置errno
```
`sockfd` 是上边`socket`函数返回的fd
`addr`是`struct sockaddr`的指针。这个结构体中保存了你的地址(端口和IP地址)信息

addrlen为`sizeof(struct sockaddr)`

errno为系统错误的一系列数组代码，每个数字都对应这一个错误
可以用`perror(const char *s)`直接输出最近的一次ERROR信息, s是增加可读性的字符串

##### sockaddr && sockaddr_in
```c++
//legency mode
// 老版本的sockaddr.sa_data[14]中存储了目标地址和端口信息
// 但是这样没可读性，也不说哪个位存的什么
struct sockaddr {
    sa_family_t sin_family;
    char sa_data[14];
};

//这种实现的方式就易读了
//强转成sockaddr型
struct sockaddr_in {
    sa_family_t sin_family; //AF_INET
    in_port_t sin_prot; //网络字节序表示的端口
    struct in_addr sin_addr; //网络地址
};

struct in_addr {
    uint32_t s_addr; //网络字节序的IP地址, 正好对应32位IPV4
}
```
#### 大小端和字节序

例如假设上述变量x类型为int，位于地址0x100处，它的值为0x01234567，地址范围为0x100~0x103字节，其内部排列顺序依赖于机器的类型。大端法从首位开始将是：0x100: 0x01, 0x101: 0x23,..。而小端法将是：0x100: 0x67, 0x101: 0x45,..
简单来说:
    大端机: 数据的低位放在低地址(地址增长方向和数据阅读方向一样)
    小端机: 数据的高位放在低地址

网络字节序 : 为大端的 

验证:
```c
#include <stdio.h>

int main() {
    int a = 0x01234567;
    char *b = (char *)&a;
    printf("%x", *b);
}
67
```
67这个低位被放到了内存的低位，本机为小端机

主机字节序要转换成网络字节序才能发送 


`htons() host to network short` 端口主机字节序转网络字节序 (short 型16位正好对应0-65535端口)

`ntohl() network to host long` IP地址网络字节序转本地字节序 (long 型32位对应IP)

`inet_addr()` 将IP字符串转换成网络字节序的整数, 用于`sockaddr_in.sin_addr.s_addr`

`inet_ntoa()` 将struct sin_addr输出成IP字符串

使用例: 
    ```c
    struct sockaddr myaddr;
    inet_aton(server_addr_string, &myaddr.sin_addr);
    //意思是将此结构体绑定到某ip地址上，即只接收此ip地址发出的数据，很少这么用 
    myaddr.sin_addr.s_addr = inet_addr("192.168.1.1"); 
    myaddr.sin_addr.s_addr = inet_addr(INADDR_ANY);
    //绑定到8888端口
    myaddr.sin_port = htons(8888);
    //0端口为随机值
    myaddr.sin_port = htons(0);
    
    ```
#### listen

`int listen(int sockfd, int blacklog);`

`sockfd` : 调用socket之后的返回值

`backlog` : 进入队列中允许的连接数? 不懂

RETURN VALUE : 错误时返回-1，并设置全局错误变量errno

#### connect
`int connect(int sockfd, const struct sockaddr *addr, socklen_t, addrlen);`

**`sockfd`是本机的socket出来的文件描述符，因为我们想访问对方的也访问不到哦，连接还没建立**

`addr`是对方的port，ip的结构体
#### accept

`int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);`
**`sockfd`是本机的socket出来的文件描述符,经历了bind和listen。处在listen状态。我们想访问对方的sockfd也访问不到哦，连接还没建立**
RETURN VALUE :
    成功返回新的sockfd(形象的例子: 当访问baidu.com的时候，我们并没有等待的时间。假设访问的是80端口，这是因为服务器将80端口拷贝了一份，实际上我们是与80
                             端口的副本建立的连接，返回这个副本的fd。所以说新的连接和listen状态的套接字无关)
连接成功，`addr`中会被记录上连接者的端口ip协议族信息

#### getpeername 获取对端地址
`int getpeername(int sockfd, struct sockaddr *addr, int *addrlen);`

`sockfd`是建立连接后的fd，即是上文`accept`的返回值
`addr` 是`accept`中记录对端信息的结构体指针

#### gethostname

`int gethostname(char *hostname, size_t size);`

#### close
`int close(int fd);`
close 底层实现了四次挥手

#### send && receive

`int send(int sockfd, const void *msg, int len, int flags);`
`flags`设置为0即可
`send && receive`实际做的工作就是写和读
用`read && write`  也是一样的

实际它做的工作就是将数据写到sockfd的发送缓冲区和从接收缓冲区拷贝出来(至于什么时候从缓冲区发出来那就是TCP协议的事)

`int recv(int sockfd, void *buf, int len, unsigned int flags);`
在四次挥手中，服务端接到`FIN`后，`recv`会返回0代表这个连接可以断开



