#### 第一题、随机数

主要思想：利用time作为随机种子产生随机数，这样可以保证每次运行程序时产生的随机数都不一样

```c++
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <vector>
using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::string;

void random(vector<int> &arr) {
    srand(time(0));
    int index, tmp;
    for (int i = 0; i < arr.size(); i++) {
        index = rand() % (arr.size() - i) + i;
        if (index != i) {
            tmp = arr[i];
            arr[i] = arr[index];
            arr[index] = tmp;
        }
    }
    return ;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    random(arr);
    for (auto x : arr) {
        cout << x << endl;
    }
}
```



#### 第二题、2^n

主要思想：利用位运算

```c++
#include <iostream>
using std::cin;
using std::cout;
using std::endl;

int is_2_power(int x) {
    if (x < 1) return 0;
    return (!(x & (x - 1)));
}
// 对于32位整形正数来说，二进制数都有一个特点即最高位为1，其余位为0
// 由于2^n不会是负数，所以负数不予考虑
// 所以x - 1 会是一个最高位位0其余位均为1的数
// 利用这一性质可以让x & (x - 1)，如果是2^n表达式结果为0
// 再对它取反即可
int main() {
    int x;
    cin >> x;
    cout << is_2_power(x) << endl;
    return 0;
}
```

#### 第三题、排序

采用未优化的快排，如果想进行优化可以采用

1. 单边递归
2. 无监督 partition，即改变边界条件判定
3. partition 的 base 数值采用三点取中
4. 分割成若干字数组，字数组间快排，内部插入排序进行收尾

```c++


#include <iostream>
using namespace std;

void quick_sort(int *num, int l, int r) {
    if (r < l) return ;
    int x = l, y = r, z = num[l];
    while (x < y) {
        while (x < y && num[y] >= z) y--;
        if (x < y) num[x++] = num[y];
        while (x < y && num[y] <= z) x++;
        if (x < y) num[y--] = num[x];
    }
    num[x] = z;
    quick_sort(num, l, x - 1);
    quick_sort(num, x + 1, r);
    return ;
}

int main() {
    int arr[4] = {3, 5, 2, 1};
    quick_sort(arr, 0, 4);
    for (int i = 0; i < 4; i++) {
        cout << arr[i] << endl;
    }
    return 0;
}
```





#### 第四题、fib数列

基本思想：递归 逆向实现

```c++

#include <iostream>
using std::cin;
using std::cout;
using std::endl;

#define MAX_N 28657
#define MAX_M 46368
int reverse_fib(int n, int m) {
    if (n == 0) return 0;
    cout << m - n << endl;
    return reverse_fib(m - n, n);
}

int main() {
    reverse_fib(MAX_N, MAX_M);
    return 0;
}
```



#### 第五题

```c++

#include <iostream>
using std::cin;
using std::cout;
using std::endl;

class A {
public :
    A(int Egg) : Egg(Egg) {}
    int Egg = 11;
};

class B {
public : 
    B(int Apple) : Apple(Apple) {}
    int Apple = 10;
};

void swapObj(A &a, B &b) {
    b.Apple = a.Egg ^ b.Apple;
    a.Egg = a.Egg ^ b.Apple;
    b.Apple = a.Egg ^ b.Apple;
    return ;
}

int main() {
    A a(11);
    B b(10);
    swapObj(a, b);
    return 0;
}

```

