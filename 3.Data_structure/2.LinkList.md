### 引入：程序内部和内存内部

程序内部定义的变量比如`int a, b; int *c;`都是在程序内部

但是链表，真正存储数据的节点们是在内存内部，程序内部存储的一般是链表的头指针。

相当于一个小抓手，来方便我们处理链表操作

<img src="/Users/renboyu/Library/Application Support/typora-user-images/截屏2021-11-17 20.21.38.png" alt="截屏2021-11-17 20.21.38" style="zoom:50%;" />

**Q：head指向链表，相当于我可以在程序中访问它，为啥不是程序内部呢？**

A：当我们改变head的值，会发现无法访问到链表。所以这个相当于一个小爪手。并且head也不是一个完整的链表节点结构，他只是存了首节点的地址

### 链表的操作：插入、删除--都要找到待操作节点的前一个节点

先找到待插入节点的前一个节点，将新节点指向前一个节点的后一个节点。

为什么不能先将前一个指向新节点呢？这样就无法访问到后一个节点了，后边的节点都丢失无法访问了。

**这里就要深刻理解线程是程序执行的最小单位，进程是操作系统分配资源的最小单位**

发生内存泄漏怎么办呢，操作系统杀死这个进程之后就能释放了。所以操作系统、守护进程一定不能内存泄漏。

<img src="/Users/renboyu/Library/Application Support/typora-user-images/截屏2021-11-18 09.00.16.png" alt="截屏2021-11-18 09.00.16" style="zoom:50%;" />

### 单向循环链表

一般来说，我们将head指针指向尾节点，这样的话我们若要在第一个节点处插入新节点就可以直接操作。因为新节点的上一个节点正是尾节点

如果，head指向的是第一个节点，那么我们在第一个节点处插入新节点就要向后走n-1步插入，这和我们的常理不符合。

注意呢，若向尾节点后边插入新节点，就要改变head的值哦。尾节点发生了变化。

**向0号位插入和向尾节点的后一位插入是不一样的！！！**

### 链表的应用场景

#### 1.操作系统内部的动态内存分配

如图：

<img src="/Users/renboyu/Library/Application Support/typora-user-images/截屏2021-11-18 13.52.55.png" alt="截屏2021-11-18 13.52.55" style="zoom:50%;" />

比如我们申请了橙色区域1GB内存，剩下两块内存就不连续了。这两块蓝色的正是靠链表链接起来的

#### 2.LRU缓存淘汰算法

Least Recently Used 最近最少使用淘汰算法

<img src="/Users/renboyu/Library/Application Support/typora-user-images/截屏2021-11-18 13.55.42.png" alt="截屏2021-11-18 13.55.42" style="zoom:50%;" />

CPU取数据可以有两种方式，CPU->MEM->DISK; CPU->DISK

在MEM中存储的比较常用的程序段，页面就是靠链表穿起来的，实际上是哈希链表

当需要新的页面或者数据的时候，先看缓存中有没有此数据，没有的话就在尾部进行添加。如果达到表长，就删除最前面的。也就是最近未使用。

