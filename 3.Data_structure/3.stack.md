
## 深入理解栈结构

#### 引入 
LEETCODE 20 括号匹配问题

Given a string s containing just the characters '(', ')', '{', '}', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.

推导为何要用栈来解决

难点是三种括号，我们不妨变成一种括号来思考，只有() 的话问题就变成了:
    1. 任意一个位置num( >= num)
    2. 最后一个位置num( = num)

所以记录lnum和rnum的数量即可

```c
bool is_vaild(char *s) {
    int lnum = 0, rnum = 0;
    int len = strlen(s);
    for (int i = 0; i < len; i++) {
        switch(s[i]) {
            case '(' : lnum += 1; break;
            case ')' : rnum += 1; break;
            defaut : return false;
        }
        if (lnum >= rnum) continue;
        return fasle;
    }
    return (lnum == rnum);
}
```
但是到这里发现其实不用两个变量，只要一个变量记录lnum和rnum的差值即可。

有(来了就num += 1，)来了就 num -= 1
每个位置num >= 0, 最后num == 0

对比栈的操作，是不是正好对应了入栈，栈顶指针 += 1；出栈栈顶指针 -= 1，并且指针 >= 0.
所以一对() 正好对应了一个完整的事件，即+1 == 事件发生了， -1 == 事件解决了
大事件和小事件之间又相互嵌套，将大事件拆成若干小事件，小事件解决了最后才解决大事件。
即先发生的事件后被解决，这不就是对应了栈的LIFO么。

所以**栈可以解决具有完全包含关系的问题**

Example:
    1. 函数的系统栈。mian函数最先被执行，最后才结束，中间我们自己写的函数就是小事件。
    2. 递归函数:
        + 语义信息
        + 边界
        + 递归过程

递归一定是向着问题规模更小的问题的，当前递归过程一定是包含了若干没有交集子问题的大问题

题外话: 树的结构，节点是集合，它的子节点是没有交集的真子集，所以也可以用递归。**树本身就是具有完全包含关系的一种结构**

回到本题，形如({)} 的是不行的，也就是部分包含关系。所以必须是完全包含关系，只需一个栈，如果是左括号就入，
右括号就比较和栈顶元素是否匹配，匹配就弹，不匹配就return false

#### 应用
栈：树的深度优先遍历，BFS
队列：树的深度优先遍历，DFS
